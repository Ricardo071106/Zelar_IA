import { DateTime, IANAZone } from 'luxon';
import * as chrono from 'chrono-node';

/**
 * Mapeamento de c√≥digos de idioma para fusos hor√°rios prov√°veis
 */
const TIMEZONE_BY_LANGUAGE: { [key: string]: string } = {
  'pt': 'America/Sao_Paulo',    // Portugu√™s - Brasil
  'pt-BR': 'America/Sao_Paulo', // Portugu√™s Brasil
  'en': 'America/New_York',     // Ingl√™s - EUA
  'es': 'Europe/Madrid',        // Espanhol - Espanha
  'es-AR': 'America/Argentina/Buenos_Aires', // Espanhol Argentina
  'es-MX': 'America/Mexico_City', // Espanhol M√©xico
  'fr': 'Europe/Paris',         // Franc√™s
  'de': 'Europe/Berlin',        // Alem√£o
  'it': 'Europe/Rome',          // Italiano
  'ru': 'Europe/Moscow',        // Russo
  'ja': 'Asia/Tokyo',           // Japon√™s
  'ko': 'Asia/Seoul',           // Coreano
  'zh': 'Asia/Shanghai',        // Chin√™s
};

/**
 * Armazenamento simples de fusos hor√°rios por usu√°rio
 */
const userTimezones = new Map<string, string>();

/**
 * Valida se um fuso hor√°rio √© v√°lido usando Luxon
 */
function isValidZone(zone: string): boolean {
  try {
    return IANAZone.isValidZone(zone);
  } catch (error) {
    return false;
  }
}

/**
 * Define o fuso hor√°rio para um usu√°rio espec√≠fico com valida√ß√£o robusta
 */
export function setUserTimezone(userId: string, timezone: string): boolean {
  try {
    // =================== CORRE√á√ÉO: VALIDA√á√ÉO ROBUSTA DE FUSO ===================
    // Primeiro validar com IANAZone
    if (!isValidZone(timezone)) {
      console.error(`‚ùå Fuso hor√°rio inv√°lido (IANA): ${timezone}`);
      return false;
    }
    
    // Segundo testar cria√ß√£o de DateTime
    const testDateTime = DateTime.now().setZone(timezone);
    if (!testDateTime.isValid) {
      console.error(`‚ùå Fuso hor√°rio inv√°lido (DateTime): ${timezone}`);
      return false;
    }
    
    userTimezones.set(userId, timezone);
    console.log(`üåç Fuso hor√°rio validado e definido para usu√°rio ${userId}: ${timezone}`);
    return true;
    // =================== FIM CORRE√á√ÉO ===================
  } catch (error) {
    console.error(`‚ùå Erro ao definir fuso hor√°rio: ${timezone}`, error);
    return false;
  }
}

/**
 * Obt√©m o fuso hor√°rio para um usu√°rio espec√≠fico
 */
export function getUserTimezone(userId: string, languageCode?: string): string {
  // 1. Verificar se o usu√°rio definiu um fuso espec√≠fico
  const userTimezone = userTimezones.get(userId);
  if (userTimezone) {
    console.log(`üåç Usando fuso definido pelo usu√°rio ${userId}: ${userTimezone}`);
    return userTimezone;
  }
  
  // 2. Tentar detectar pelo c√≥digo de idioma
  if (languageCode) {
    const detectedTimezone = TIMEZONE_BY_LANGUAGE[languageCode] || TIMEZONE_BY_LANGUAGE[languageCode.split('-')[0]];
    if (detectedTimezone) {
      console.log(`üåç Fuso detectado pelo idioma ${languageCode}: ${detectedTimezone}`);
      return detectedTimezone;
    }
  }
  
  // 3. Padr√£o: S√£o Paulo (maioria dos usu√°rios s√£o brasileiros)
  console.log(`üåç Usando fuso padr√£o: America/Sao_Paulo`);
  return 'America/Sao_Paulo';
}

/**
 * Lista de fusos hor√°rios v√°lidos para sugest√µes
 */
export const COMMON_TIMEZONES = [
  'America/Sao_Paulo',          // Brasil
  'America/Argentina/Buenos_Aires', // Argentina
  'America/New_York',           // EUA Costa Leste
  'America/Los_Angeles',        // EUA Costa Oeste
  'America/Mexico_City',        // M√©xico
  'Europe/London',              // Reino Unido
  'Europe/Paris',               // Fran√ßa/Alemanha
  'Europe/Madrid',              // Espanha
  'Asia/Tokyo',                 // Jap√£o
  'Asia/Shanghai',              // China
  'Australia/Sydney',           // Austr√°lia
];

/**
 * Preprocessa texto em portugu√™s para melhor interpreta√ß√£o do chrono-node
 */
function preprocessPortugueseText(input: string): string {
  let processed = input.toLowerCase().trim();
  
  // Substitui√ß√µes que ajudam o chrono-node portugu√™s
  const replacements: { [key: string]: string } = {
    '√†s': '√†s',  // manter
    'as': '√†s',  // normalizar
    'amanh√£': 'amanh√£',
    'amanha': 'amanh√£',
    'hoje': 'hoje',
    'segunda-feira': 'segunda',
    'ter√ßa-feira': 'ter√ßa',
    'terca-feira': 'ter√ßa',
    'quarta-feira': 'quarta',
    'quinta-feira': 'quinta',
    'sexta-feira': 'sexta',
    's√°bado': 's√°bado',
    'sabado': 's√°bado'
  };
  
  Object.entries(replacements).forEach(([original, replacement]) => {
    const regex = new RegExp(`\\b${original}\\b`, 'gi');
    processed = processed.replace(regex, replacement);
  });
  
  return processed;
}

/**
 * Corrige hor√°rio quando h√° "da noite" e hora < 12
 */
function correctNightTime(originalInput: string, parsedDate: Date): Date {
  const input = originalInput.toLowerCase();
  const hasNightIndicator = /\b(da noite|de noite)\b/.test(input);
  
  if (!hasNightIndicator) {
    return parsedDate;
  }
  
  const hour = parsedDate.getHours();
  
  // Se tem "da noite" e a hora √© menor que 12, adicionar 12 horas
  if (hour < 12) {
    console.log(`üåô Corre√ß√£o noite: ${hour}h ‚Üí ${hour + 12}h`);
    const correctedDate = new Date(parsedDate);
    correctedDate.setHours(hour + 12);
    return correctedDate;
  }
  
  return parsedDate;
}

/**
 * Fun√ß√£o principal para interpretar datas com fuso hor√°rio do usu√°rio (h√≠brida)
 */
export function parseUserDateTime(
  input: string, 
  userId: string, 
  languageCode?: string
): { iso: string; readable: string } | null {
  try {
    console.log(`üîç Analisando "${input}" para usu√°rio ${userId}`);
    
    // Obter fuso hor√°rio do usu√°rio com valida√ß√£o
    let userTimezone = getUserTimezone(userId, languageCode);
    
    // =================== CORRE√á√ÉO: VALIDAR FUSO ANTES DE USAR ===================
    if (!isValidZone(userTimezone)) {
      console.error(`‚ùå Fuso inv√°lido detectado: ${userTimezone}, usando fallback`);
      userTimezone = 'America/Sao_Paulo'; // Fallback seguro
    }
    
    // =================== CORRE√á√ÉO: PARSING SIMPLIFICADO E ROBUSTO ===================
    // Extrair hora com m√∫ltiplas tentativas antes de usar padr√£o
    let timeResult = extractTimeFromText(input);
    
    // CORRE√á√ÉO: Se n√£o conseguiu extrair, tentar padr√µes mais simples
    if (!timeResult) {
      // Tentar detectar n√∫meros isolados ap√≥s palavras de tempo
      const simpleTimeMatch = input.toLowerCase().match(/\b(?:√†s|as|ate)\s+(\d{1,2})\b/);
      if (simpleTimeMatch) {
        const hourFound = parseInt(simpleTimeMatch[1]);
        if (hourFound >= 0 && hourFound <= 23) {
          timeResult = { hour: hourFound, minute: 0 };
          console.log(`üïê CORRE√á√ÉO SIMPLES - Detectado: "${simpleTimeMatch[0]}" ‚Üí ${hourFound}:00`);
        }
      }
    }
    
    const hour = timeResult?.hour ?? 9;
    const minute = timeResult?.minute ?? 0;
    
    console.log(`üïê Hora extra√≠da: ${timeResult ? `${hour}:${minute}` : 'padr√£o 9:00'}`);
    
    // Extrair data passando hor√°rio para l√≥gica inteligente de "hoje"
    const dateResult = extractDateFromText(input, userTimezone, hour, minute);
    
    if (!dateResult) {
      console.log(`‚ùå N√£o conseguiu extrair data de: "${input}"`);
      return null;
    }
    
    console.log(`üìÖ Data extra√≠da: ${dateResult.toDateString()}`);
    
    // =================== CORRE√á√ÉO: INTERPRETAR HOR√ÅRIO COMO LOCAL COM VALIDA√á√ÉO ===================
    // Criar data/hora diretamente no fuso do usu√°rio
    const userDateTime = DateTime.fromJSDate(dateResult, { zone: userTimezone })
      .set({ hour, minute, second: 0, millisecond: 0 });
    
    // Validar se o DateTime criado √© v√°lido
    if (!userDateTime.isValid) {
      console.error(`‚ùå DateTime inv√°lido criado com fuso ${userTimezone}`);
      return null;
    }
    
    console.log(`üìÖ Data/hora criada no fuso ${userTimezone}: ${userDateTime.toISO()}`);
    // =================== FIM CORRE√á√ÉO ===================
    
    // Gerar os dois formatos com valida√ß√£o
    const iso = userDateTime.toISO();
    if (!iso) {
      console.error(`‚ùå N√£o foi poss√≠vel gerar ISO string`);
      return null;
    }
    
    const readable = userDateTime.setLocale('pt-BR').toFormat('cccc, dd \'de\' LLLL \'√†s\' HH:mm');
    
    console.log(`‚úÖ Resultado final:`);
    console.log(`üìÖ ISO (${userTimezone}): ${iso}`);
    console.log(`üìã Leg√≠vel: ${readable}`);
    
    return { iso, readable };
    
  } catch (error) {
    console.error(`‚ùå Erro ao interpretar "${input}":`, error);
    return null;
  }
}

/**
 * Encontra a pr√≥xima ocorr√™ncia de um dia da semana no futuro
 */
function getNextWeekdayDate(weekday: number, hour: number, minute: number, zone: string): DateTime {
  // =================== CORRE√á√ÉO: VALIDAR FUSO ANTES DE USAR ===================
  if (!isValidZone(zone)) {
    console.error(`‚ùå Fuso inv√°lido em getNextWeekdayDate: ${zone}, usando fallback`);
    zone = 'America/Sao_Paulo'; // Fallback seguro
  }
  
  const now = DateTime.now().setZone(zone);
  if (!now.isValid) {
    console.error(`‚ùå DateTime inv√°lido com fuso ${zone}`);
    return DateTime.now(); // Fallback
  }
  
  let date = now.startOf('day');
  
  // Se √© hoje e o hor√°rio ainda n√£o passou, usar hoje
  if (date.weekday === weekday) {
    const todayWithTime = now.set({ hour, minute, second: 0, millisecond: 0 });
    if (todayWithTime.isValid && todayWithTime > now) {
      console.log(`üìÖ Agendando para hoje mesmo (${date.toFormat('cccc')}) pois hor√°rio ainda n√£o passou`);
      return date;
    }
  }
  
  // Procurar pr√≥xima ocorr√™ncia do dia da semana
  while (date.weekday !== weekday || date <= now.startOf('day')) {
    date = date.plus({ days: 1 });
  }
  
  console.log(`üìÖ Pr√≥xima ${['', 'segunda', 'ter√ßa', 'quarta', 'quinta', 'sexta', 's√°bado', 'domingo'][weekday]}: ${date.toFormat('cccc, dd/MM')}`);
  return date;
}

/**
 * Extrai data usando Luxon para garantir pr√≥xima ocorr√™ncia futura
 */
function extractDateFromText(input: string, userTimezone: string = 'America/Sao_Paulo', hour: number = 9, minute: number = 0): Date | null {
  try {
    const text = input.toLowerCase();
    
    // =================== CORRE√á√ÉO: L√ìGICA DE DIAS DA SEMANA COM LUXON ===================
    
    // Mapear dias da semana (Luxon: 1=segunda, 7=domingo)
    const weekdays: { [key: string]: number } = {
      'segunda': 1, 'segunda-feira': 1,
      'ter√ßa': 2, 'terca': 2, 'ter√ßa-feira': 2, 'terca-feira': 2,
      'quarta': 3, 'quarta-feira': 3,
      'quinta': 4, 'quinta-feira': 4,
      'sexta': 5, 'sexta-feira': 5,
      's√°bado': 6, 'sabado': 6,
      'domingo': 7
    };
    
    // Verificar se cont√©m dia da semana
    for (const [dayName, weekdayNum] of Object.entries(weekdays)) {
      if (text.includes(dayName)) {
        console.log(`üìÖ Detectado dia da semana: ${dayName} (${weekdayNum})`);
        const nextDate = getNextWeekdayDate(weekdayNum, hour, minute, userTimezone);
        return nextDate.toJSDate();
      }
    }
    
    // Casos especiais
    if (text.includes('hoje')) {
      console.log(`üìÖ Detectado: hoje`);
      return DateTime.now().setZone(userTimezone).startOf('day').toJSDate();
    }
    
    if (text.includes('amanh√£') || text.includes('amanha')) {
      console.log(`üìÖ Detectado: amanh√£`);
      return DateTime.now().setZone(userTimezone).plus({ days: 1 }).startOf('day').toJSDate();
    }
    
    // =================== CORRE√á√ÉO: SUPORTE PARA DATAS BRASILEIRAS DD/MM/AAAA ===================
    
    // 1. PRIMEIRO: Tentar detectar formatos DD/MM ou DD/MM/AAAA
    const brazilianDateRegex = /\b(\d{1,2})[\/\-](\d{1,2})(?:[\/\-](\d{2,4}))?\b/;
    const dateMatch = text.match(brazilianDateRegex);
    
    if (dateMatch) {
      let [_, dayStr, monthStr, yearStr] = dateMatch;
      const day = parseInt(dayStr);
      const month = parseInt(monthStr) - 1; // JavaScript months are 0-indexed
      const now = DateTime.now().setZone(userTimezone);
      let year = yearStr ? parseInt(yearStr) : now.year;
      
      // Ajustar ano de 2 d√≠gitos (26 ‚Üí 2026)
      if (yearStr && yearStr.length === 2) {
        const shortYear = parseInt(yearStr);
        year = shortYear < 50 ? 2000 + shortYear : 1900 + shortYear;
      }
      
      // =================== CORRE√á√ÉO: VALIDA√á√ÉO ROBUSTA DE DATAS ===================
      // Validar intervalos mais precisos para dia e m√™s
      const daysInMonth = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // considerando ano bissexto
      const maxDayForMonth = daysInMonth[month] || 31;
      
      if (day >= 1 && day <= maxDayForMonth && month >= 0 && month <= 11) {
        try {
          let parsedDate = DateTime.fromObject({ 
            year, 
            month: month + 1, // Luxon usa meses 1-indexed
            day, 
            hour, 
            minute 
          }, { zone: userTimezone });
          
          // Verificar se a data √© v√°lida (Luxon detecta datas inv√°lidas como 31/02)
          if (!parsedDate.isValid) {
            console.log(`‚ùå Data inv√°lida detectada: ${day}/${month + 1}/${year} - ${parsedDate.invalidReason}`);
            return null;
          }
          
          // Se n√£o foi informado ano e a data j√° passou este ano, usar pr√≥ximo ano
          if (!yearStr && parsedDate < now) {
            parsedDate = parsedDate.plus({ years: 1 });
            console.log(`üìÖ Data passou este ano, ajustando para pr√≥ximo ano`);
          }
          
          console.log(`üìÖ Data brasileira v√°lida: ${day}/${month + 1}/${year} ‚Üí ${parsedDate.toFormat('dd/MM/yyyy')}`);
          return parsedDate.toJSDate();
        } catch (error) {
          console.log(`‚ùå Erro ao criar data ${day}/${month + 1}/${year}: ${error}`);
          return null;
        }
      } else {
        console.log(`‚ùå Data fora do intervalo v√°lido: dia ${day}, m√™s ${month + 1}`);
        return null;
      }
    }
    
    // 2. FALLBACK: usar chrono-node para outros casos
    const pt = chrono.pt;
    const processedInput = preprocessPortugueseText(input);
    
    const dateOnlyInput = processedInput
      .replace(/\b√†s?\s+\w+/gi, '')
      .replace(/\b\d{1,2}h?\b/gi, '')
      .replace(/\b(da manh√£|da tarde|da noite|de manh√£|de tarde|de noite)\b/gi, '')
      .trim();
    
    const parseResults = pt.parse(dateOnlyInput, new Date(), { forwardDate: true });
    
    if (parseResults.length > 0) {
      const parsedDate = parseResults[0].start.date();
      console.log(`üìÖ Chrono-node detectou: ${parsedDate.toDateString()}`);
      
      // Garantir que √© futuro
      const now = DateTime.now().setZone(userTimezone);
      const resultDateTime = DateTime.fromJSDate(parsedDate, { zone: userTimezone });
      
      if (resultDateTime < now.startOf('day')) {
        console.log(`üìÖ Data no passado, ajustando para pr√≥xima semana`);
        return resultDateTime.plus({ weeks: 1 }).toJSDate();
      }
      
      return parsedDate;
    }
    
    return null;
  } catch (error) {
    console.error('Erro ao extrair data:', error);
    return null;
  }
}

/**
 * Extrai hor√°rio usando parser customizado com suporte robusto para AM/PM
 * CORRE√á√ÉO: Prioriza formatos AM/PM e suporte para minutos (ex: 6:30pm ‚Üí 18:30)
 */
function extractTimeFromText(input: string): { hour: number, minute: number } | null {
  const text = input.toLowerCase().trim();
  
  // =================== CORRE√á√ÉO: PARSING AM/PM PRIORIT√ÅRIO ===================
  
  // 1. PRIMEIRO: Formato AM/PM com minutos (6:30pm, 7:15am)
  const ampmWithMinutesMatch = text.match(/\b(\d{1,2}):(\d{2})\s*(am|pm)\b/i);
  if (ampmWithMinutesMatch) {
    let hour = parseInt(ampmWithMinutesMatch[1]);
    const minute = parseInt(ampmWithMinutesMatch[2]);
    const period = ampmWithMinutesMatch[3].toLowerCase();
    
    // Converter para formato 24h
    if (period === 'pm' && hour < 12) {
      hour += 12;
    } else if (period === 'am' && hour === 12) {
      hour = 0;
    }
    
    console.log(`üïê AM/PM com minutos: ${ampmWithMinutesMatch[1]}:${ampmWithMinutesMatch[2]}${period} ‚Üí ${hour}:${minute}`);
    return { hour, minute };
  }
  
  // 2. Formato AM/PM simples (6pm, 7am)
  const ampmMatch = text.match(/\b(\d{1,2})\s*(am|pm)\b/i);
  if (ampmMatch) {
    let hour = parseInt(ampmMatch[1]);
    const period = ampmMatch[2].toLowerCase();
    
    // Converter para formato 24h
    if (period === 'pm' && hour < 12) {
      hour += 12;
    } else if (period === 'am' && hour === 12) {
      hour = 0;
    }
    
    console.log(`üïê AM/PM simples: ${ampmMatch[1]}${period} ‚Üí ${hour}:00`);
    return { hour, minute: 0 };
  }
  
  // 3. CORRE√á√ÉO: Formato "√†s X h" priorit√°rio (para evitar capturar n√∫meros de datas)
  const explicitTimeMatch = text.match(/\b(?:√†s|as)\s+(\d{1,2})(?::(\d{2}))?\s*h?\b/i);
  if (explicitTimeMatch) {
    const hour = parseInt(explicitTimeMatch[1]);
    const minute = parseInt(explicitTimeMatch[2] || '0');
    
    if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
      console.log(`üïê CORRE√á√ÉO - Hor√°rio expl√≠cito: "${explicitTimeMatch[0]}" ‚Üí ${hour}:${minute.toString().padStart(2, '0')}`);
      return { hour, minute };
    }
  }
  
  // 4. Formato num√©rico seguido de h (19h, 18:30h) - MAS apenas no final da frase
  const hourSuffixMatch = text.match(/\b(\d{1,2})(?::(\d{2}))?\s*h\b(?!\s*\w)/i);
  if (hourSuffixMatch && !text.includes('am') && !text.includes('pm')) {
    const hour = parseInt(hourSuffixMatch[1]);
    const minute = parseInt(hourSuffixMatch[2] || '0');
    
    if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
      console.log(`üïê CORRE√á√ÉO - Hor√°rio com 'h': "${hourSuffixMatch[0]}" ‚Üí ${hour}:${minute.toString().padStart(2, '0')}`);
      return { hour, minute };
    }
  }
  
  // 4. CORRE√á√ÉO: Detec√ß√£o robusta de n√∫meros isolados no contexto de hora
  // Prioriza n√∫meros ap√≥s indicadores de tempo como "√†s", "as", isolados ou com "h"
  const timeContextPatterns = [
    // Padr√µes com indicadores de tempo expl√≠citos
    /\b(?:√†s|as)\s+(\d{1,2})(?:\s*h(?:oras?)?)?(?!\d)/gi,     // "√†s 19", "as 19", "√†s 19h"
    /\b(\d{1,2})\s*(?:h|horas?)(?!\d)/gi,                     // "19h", "19 horas"
    /\b(\d{1,2})(?:\s*:\s*(\d{2}))?\s*(?:h|horas?)(?!\d)/gi   // "19:30h", "19:00 horas"
  ];
  
  for (const pattern of timeContextPatterns) {
    pattern.lastIndex = 0; // Reset regex global flag
    const match = pattern.exec(text);
    if (match && !text.includes('am') && !text.includes('pm')) {
      const hour = parseInt(match[1]);
      const minute = parseInt(match[2] || '0');
      
      if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
        console.log(`üïê CORRE√á√ÉO - Contexto temporal detectado: "${match[0].trim()}" ‚Üí ${hour}:${minute.toString().padStart(2, '0')}`);
        return { hour, minute };
      }
    }
  }
  
  // 5. N√∫meros por extenso com contexto de per√≠odo
  const wordNumbers: { [key: string]: number } = {
    'uma': 1, 'dois': 2, 'tr√™s': 3, 'tres': 3, 'quatro': 4, 'cinco': 5,
    'seis': 6, 'sete': 7, 'oito': 8, 'nove': 9, 'dez': 10,
    'onze': 11, 'doze': 12, 'treze': 13, 'catorze': 14, 'quatorze': 14,
    'quinze': 15, 'dezesseis': 16, 'dezessete': 17, 'dezoito': 18,
    'dezenove': 19, 'vinte': 20, 'vinte e uma': 21, 'vinte e dois': 22,
    'vinte e tr√™s': 23, 'vinte e tres': 23
  };
  
  for (const [word, number] of Object.entries(wordNumbers)) {
    if (new RegExp(`\\b${word}\\b`).test(text)) {
      let hour = number;
      
      // Ajustar para per√≠odo da tarde/noite (apenas se < 12)
      if (/\b(da tarde|de tarde|da noite|de noite)\b/.test(text) && hour < 12) {
        hour += 12;
        console.log(`üåô Ajuste per√≠odo: ${number} ‚Üí ${hour} (${word})`);
      }
      
      console.log(`üïê Por extenso: ${word} ‚Üí ${hour}:00`);
      return { hour, minute: 0 };
    }
  }
  
  console.log(`‚ùå Nenhum hor√°rio encontrado em: "${input}"`);
  return null;
}

